# HostDirectivesApp

<a href="https://nx.dev" target="_blank" rel="noreferrer"><img src="https://raw.githubusercontent.com/nrwl/nx/master/images/nx-logo.png" width="45"></a>

✨ **This workspace has been generated by [Nx, a Smart, fast and extensible build system.](https://nx.dev)** ✨

## Development server

Run `nx serve host-directives-app` for a dev server. Navigate to http://localhost:4200/. The app will automatically reload if you change any of the source files.

## Understand this workspace

Run `nx graph` to see a diagram of the dependencies of the projects.

## Remote caching

Run `npx nx connect-to-nx-cloud` to enable [remote caching](https://nx.app) and make CI faster.

## Further help

Visit the [Nx Documentation](https://nx.dev) to learn more.


=============

Not while ago, Angular team released stable 15 version with few neat features, such as host directives.
In this article I will try to explain how to leverage directive composition approach and move from old class-inheritance to a composition approach.

## What are host directives?
Host directives is a **standalone** directives that can be added to a component via `@Component` decorator, thus avoiding the need to apply the directive through the markup. Developers can expose it's inputs and outputs. Additionally, they can also map their names to avoid the confusion between components and directives properties.

## Why would you want to use host directives?
With complex component comes complex business logic inside it's class. Typescript has [mixins](https://www.typescriptlang.org/docs/handbook/mixins.html) support to divide logic between multiple classes and then join it into one giant class.

Unfortunately, this approach doesn't work well with angular's compiler, so developers had to use long chains of inheritance and services.

In the end, final component would have a huge constructor (prior to `inject` function) and supporting this constructor sometimes was too painful.

Directive composition approach works similarly to the Typescript's mixins: you have multiple classes that contain own logic, and in the end they all end up used for one final class (component).

Let's take an example of simple form control component:

{% embed https://gist.github.com/N1XUS/4da4768eddc51f923c13fab66b9a0d2c %}

This component implements `ControlValueAccessor` and implements it's methods such as `writeValue`, `registerOnChange`, `registerOnTouched`.
And this stuff is commonly repeated across multiple components in your app.
Previously, to simplify the logic you could extract those methods into base abstract class. But this class might require it's dependencies, which needed to be passed via `super` call in constructor. This complicates the things.

Let's simplify the code, and first, create standalone directive called `CvaDirective`.

{% embed https://gist.github.com/N1XUS/75ae36d6f3becdbcba13e7a4a677d9eb %}



Let me explain what's going on inside this directive.
First, we are declaring it as a standalone, which means we can apply it to a component via `hostDirectives` property of the `@Component`.
Next, since we need to support template-driven and reactive forms, lets' inject necessary dependencies such as `NgControl`, `NgForm` and `ControlContainer`. We will need there properties later.

You may see that we also injected `ChangeDetectorRef` from `host`. This is needed to get the components change detector and call it when the state of the control being changed (valid/invalid).

Next, we implement all members of `ControlValueAccessor` interface for further usage in the component.
We also have a support for a disabled state of the form control, which may be handy in real-case scenarios. This input property is optional and you can ignore it during input exposing.

We are also have `updateErrorState` method which automatically checks whether the control is valid and check whether user interacted with the control itself.

That's all for the directive itself, now let's update our combobox component to use this directive instead direct `ControlValueAccessor` implementation:

{% embed https://gist.github.com/N1XUS/d3971a875f9e4901682dd402e36936ec %}

So, we've removed all form-related stuff to the directive. This gives us more clear and readable component.

You see that we've injected `CvaDirective` into component to call it's members such as `setValue` and use initial value of the form control to set it for the input field.

## Advanced Directives composition
With the example above I've shown how to simplify your component and move all background logic into separate class without the need of inheritance.

Now let's update our component. Let's say we want it to accept not only `string[]`, but `Observable<string[]>`, or even custom data source class which retrieves the data from some backend.

And again, host directives to the rescue!

Before we start with the directive itself, let's define what our directive should support:

- Be as generic as possible to support multiple scenarios for different types of components.
- Automatically subscribe/unsubscribe from the dataSource;
- When datasource's data changes, or new dataSource instance being passed, notify parent component of the changes in data;
- Support async data retrieval (notify of loading start and loading end);

With the plan defined, let's start with component-agnostic approach.
We would need some abstract class to be a ground for all data source providers. Let's start with abstract class called `AbstractDataSourceProvider` which our components data sources would extend from:

{% embed https://gist.github.com/N1XUS/5b5ab08a2f384bf658b08386bfbe585c %}

Here we see the `match` method, which retrieves the data from the data provider (class that actually responsible for data retrieval)

Let's generate new standalone directive called `DataSourceDirective`.
